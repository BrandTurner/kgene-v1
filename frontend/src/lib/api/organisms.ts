/**
 * Organisms API - CRUD Operations
 *
 * üéì LEARNING NOTE: API Module Pattern
 *
 * This file exports functions that call API endpoints.
 * Each function:
 *   1. Takes typed parameters
 *   2. Makes HTTP request with Axios
 *   3. Returns typed response data
 *
 * Why separate API functions from React components?
 *   - Reusability: Use same function in multiple components
 *   - Testability: Easy to test without React
 *   - Type safety: Centralized type definitions
 *   - Maintainability: Change API endpoint in one place
 */

import { apiClient } from './client'
import type {
  Organism,
  OrganismCreate,
  OrganismUpdate,
  OrganismFilters,
} from '@/types'

/**
 * Get all organisms with optional filtering
 *
 * üéì LEARNING NOTE: async/await
 *
 * async: Declares function returns a Promise
 * await: Pauses execution until Promise resolves
 *
 * Example WITHOUT async/await (old way):
 *   function getOrganisms() {
 *     return apiClient.get('/organisms')
 *       .then(response => response.data)
 *       .catch(error => { throw error })
 *   }
 *
 * Example WITH async/await (modern):
 *   async function getOrganisms() {
 *     const { data } = await apiClient.get('/organisms')
 *     return data
 *   }
 *
 * Benefits:
 *   - Looks like synchronous code (easier to read)
 *   - Better error handling with try/catch
 *   - No callback hell
 *
 * @param filters - Optional filters for organism list
 * @returns Array of organisms matching filters
 *
 * @example
 * ```typescript
 * // Get all organisms
 * const all = await getOrganisms()
 *
 * // Get only completed organisms
 * const completed = await getOrganisms({ status: 'complete' })
 *
 * // Get organisms with "eco" in code, sorted by name
 * const filtered = await getOrganisms({
 *   code_pattern: 'eco',
 *   sort_by: 'name',
 *   order: 'asc'
 * })
 * ```
 */
export async function getOrganisms(
  filters?: OrganismFilters
): Promise<Organism[]> {
  /**
   * üéì LEARNING NOTE: Generic Type Parameter <Organism[]>
   *
   * apiClient.get<Organism[]>(...) tells TypeScript:
   *   "The response.data will be an array of Organism objects"
   *
   * Now TypeScript knows:
   *   data[0].code  // ‚úÖ Autocomplete works!
   *   data[0].foo   // ‚ùå Error: Property 'foo' doesn't exist
   */
  const { data } = await apiClient.get<Organism[]>('/organisms', {
    /**
     * üéì LEARNING NOTE: Query Parameters
     *
     * params: { key: value } becomes ?key=value in URL
     *
     * Example:
     *   params: { status: 'complete', limit: 10 }
     *   URL: /organisms?status=complete&limit=10
     *
     * Axios automatically:
     *   - Encodes special characters
     *   - Skips undefined/null values
     *   - Serializes arrays and objects
     */
    params: filters,
  })

  return data
}

/**
 * Get a single organism by ID
 *
 * @param id - Organism ID
 * @returns Single organism object
 * @throws {ApiError} If organism not found (404)
 *
 * @example
 * ```typescript
 * const organism = await getOrganism(1)
 * console.log(organism.name)  // "Escherichia coli"
 * ```
 */
export async function getOrganism(id: number): Promise<Organism> {
  const { data } = await apiClient.get<Organism>(`/organisms/${id}`)
  return data
}

/**
 * Create a new organism
 *
 * üéì LEARNING NOTE: Function Parameters with Types
 *
 * organismData: OrganismCreate
 *   - Parameter name: organismData
 *   - Type: OrganismCreate
 *
 * TypeScript ensures you pass the right shape:
 *   ‚úÖ createOrganism({ code: "eco", name: "E. coli" })
 *   ‚ùå createOrganism({ foo: "bar" })  // Error: 'foo' doesn't exist on OrganismCreate
 *   ‚ùå createOrganism({ code: "eco" })  // Error: 'name' is required
 *
 * @param organismData - Organism data to create
 * @returns Newly created organism (with id, timestamps)
 * @throws {ApiError} If organism code already exists (409 Conflict)
 * @throws {ApiError} If validation fails (400 Bad Request)
 *
 * @example
 * ```typescript
 * const newOrg = await createOrganism({
 *   code: "eco",
 *   name: "Escherichia coli K-12 MG1655"
 * })
 *
 * console.log(newOrg.id)  // 1 (generated by database)
 * console.log(newOrg.created_at)  // "2025-12-03T12:00:00Z"
 * ```
 */
export async function createOrganism(
  organismData: OrganismCreate
): Promise<Organism> {
  /**
   * POST request: Send data in request body
   *
   * Axios automatically:
   *   - Converts organismData to JSON
   *   - Sets Content-Type: application/json header
   *   - Parses JSON response
   */
  const { data } = await apiClient.post<Organism>('/organisms', organismData)
  return data
}

/**
 * Update an existing organism
 *
 * @param id - Organism ID to update
 * @param updates - Partial organism data to update
 * @returns Updated organism object
 * @throws {ApiError} If organism not found (404)
 * @throws {ApiError} If validation fails (400)
 *
 * @example
 * ```typescript
 * // Update only the name
 * const updated = await updateOrganism(1, {
 *   name: "Escherichia coli (updated)"
 * })
 *
 * // Update multiple fields
 * const updated2 = await updateOrganism(2, {
 *   name: "New name",
 *   status: "complete"
 * })
 * ```
 */
export async function updateOrganism(
  id: number,
  updates: OrganismUpdate
): Promise<Organism> {
  /**
   * PUT request: Update resource
   *
   * üéì LEARNING NOTE: PUT vs PATCH
   *   - PUT: Replace entire resource
   *   - PATCH: Update specific fields
   *
   * Our backend uses PUT but accepts partial updates,
   * so it behaves like PATCH.
   */
  const { data } = await apiClient.put<Organism>(`/organisms/${id}`, updates)
  return data
}

/**
 * Delete an organism
 *
 * üéì LEARNING NOTE: void Return Type
 *
 * void means "this function doesn't return anything useful"
 *
 * DELETE requests typically return:
 *   - 204 No Content (no body)
 *   - 200 OK with success message
 *
 * We don't need the response, so return type is void.
 *
 * @param id - Organism ID to delete
 * @throws {ApiError} If organism not found (404)
 *
 * @example
 * ```typescript
 * await deleteOrganism(1)  // Returns nothing
 * console.log('Organism deleted!')
 * ```
 */
export async function deleteOrganism(id: number): Promise<void> {
  /**
   * DELETE request: Remove resource
   *
   * We don't care about the response, just that it succeeded.
   * If it fails, apiClient interceptor throws ApiError.
   */
  await apiClient.delete(`/organisms/${id}`)
}

/**
 * üéì LEARNING NOTE: Named Exports
 *
 * We export individual functions with "export" keyword.
 *
 * Usage:
 *   import { getOrganisms, createOrganism } from '@/lib/api/organisms'
 *
 * Alternative (default export):
 *   export default { getOrganisms, createOrganism, ... }
 *   import organisms from '@/lib/api/organisms'
 *   organisms.getOrganisms()
 *
 * Named exports are preferred because:
 *   - Better tree-shaking (unused functions removed)
 *   - Consistent naming (no renaming imports)
 *   - Better autocomplete
 */
